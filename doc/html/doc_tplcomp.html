
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Template Computation</title><meta name="generator" content="MATLAB 9.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-02-16"><meta name="DC.source" content="doc_tplcomp.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Template Computation</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Overview</a></li><li><a href="#4">Plotting Templates</a></li><li><a href="#7">Template Union</a></li></ul></div><h2 id="1">Overview</h2><p>The second stage in QFT design is to compute the uncertain templates. In <b>open Qsyn</b> templates are computed from <tt>qplant</tt> objects using the command <a href="matlab:doc('qplant/ctpl')"><tt>ctpl</tt></a>. <b>Open Qsyn</b> offers several options for the template computation:</p><div><ul><li>Grid</li><li>Random Grid</li><li>Random Samples</li><li>Recursive edge grid</li><li>Recursive grid</li><li>Cases</li></ul></div><p>To compute the templates using specified <tt>method</tt> at frequencies <tt>w</tt> type</p><pre class="language-matlab">ctpl(P,method,w)
</pre><p>The nominal plant is computed by <a href="matlab:doc('qplant.cnom')"><tt>cnom</tt></a>. Use as</p><pre class="language-matlab">cnom(P,w_nom)
</pre><p><b>Example</b>: compute the templates fot the plant</p><p><span class="MathJax_Preview"><img src="doc_tplcomp_eq04896201087436659779.png" alt="$$ P(s) = \frac{\omega^2}{s^2 + 2\zeta \omega + \omega^2}, ~~ \omega \in [10,20], ~~ \zeta \in [0.3,0.5]$$"></span><script type="math/tex"> P(s) = \frac{\omega^2}{s^2 + 2\zeta \omega + \omega^2}, ~~ \omega \in [10,20], ~~ \zeta \in [0.3,0.5]</script></p><p>at freqeuncies <span class="MathJax_Preview"><img src="doc_tplcomp_eq04699568093166099010.png" alt="$\omega = \{ 0.1,~ 0.2,~ 0.5,~ 1,~ 3,~ 5,~ 10,~ 20,~ 50, \}$"></span><script type="math/tex">\omega = \{ 0.1,~ 0.2,~ 0.5,~ 1,~ 3,~ 5,~ 10,~ 20,~ 50, \}</script> rad/s, using a unifor grid of 5 points for <span class="MathJax_Preview"><img src="doc_tplcomp_eq08589834809570054062.png" alt="$\omega$"></span><script type="math/tex">\omega</script> and 6 points for <span class="MathJax_Preview"><img src="doc_tplcomp_eq13496487163394900197.png" alt="$\zeta$"></span><script type="math/tex">\zeta</script>.</p><pre class="codeinput">omega = qpar(<span class="string">'w'</span>,10,10,20,5);
zeta = qpar(<span class="string">'z'</span>,0.3,0.3,0.5,6);
num = omega*omega;
den = [1 2*zeta*omega omega*omega];
P = qplant(num,den)
</pre><pre class="codeoutput">
P = 

  qplant with properties:

          num: [1&times;1 qexpression]
          den: [1&times;1 qpoly]
         pars: [2&times;1 qpar]
        delay: []
     unstruct: []
       uncint: []
         info: 'generated from [num,den] data on: 16-Feb-2019 22:33:51'
    templates: []
      nominal: []

</pre><p>Since the nominal parameter values were not defined, we arbitrarly select them as the lower values. We now compute thew desired templates and also the nominal case</p><pre class="codeinput">w_tpl = [0.1 0.2 0.5 1 3 5 10 20 50];
ctpl(P,<span class="string">'grid'</span>,w_tpl);
w_nom = logspace(-2,2,200);
cnom(P,w_nom);
</pre><pre class="codeoutput">Calculating templates using the grid method 
--&gt; for w=0.1 [rad/s] 
--&gt; for w=0.2 [rad/s] 
--&gt; for w=0.5 [rad/s] 
--&gt; for w=1 [rad/s] 
--&gt; for w=3 [rad/s] 
--&gt; for w=5 [rad/s] 
--&gt; for w=10 [rad/s] 
--&gt; for w=20 [rad/s] 
--&gt; for w=50 [rad/s] 
</pre><h2 id="4">Plotting Templates</h2><p>Note that now the <tt>templates</tt> and <tt>nominal</tt> preperties are no longer empty. The computed templates are stores in a dedicated class <a href="matlab:doc('qtpl')"><tt>qtpl</tt></a>. They can be shown by the command <a href="matlab:doc('qtpl/show')"><tt>show</tt></a>. To acsess the temalptes use <tt>P.templates</tt>. The nominal point is always computed and stored at the first point in the template. It is marked with a square.</p><pre class="codeinput">T1 = P.templates;
show(T1);
</pre><img vspace="5" hspace="5" src="doc_tplcomp_01.png" alt=""> <p>To save time and keystrokes one can instead use the <a href="matlab:doc('qplant/showtpl')"><tt>showtpl</tt></a> command directly on the plant object. Both <tt>qplt/show</tt> and <tt>qplant/showtpl</tt> accepts more input arguments that specify additional options. For e.g. to plot the template at 10 rad/s with red circle markers:</p><pre class="codeinput">showtpl(P,10,<span class="string">'color'</span>,[1 0 0],<span class="string">'marker'</span>,<span class="string">'o'</span>,<span class="string">'mode'</span>,<span class="string">'nonom'</span>)
</pre><img vspace="5" hspace="5" src="doc_tplcomp_02.png" alt=""> <p>The nominal is stored in a dedicated class <a href="matlab:doc('qfr')"><tt>qfr</tt></a>. A <tt>qfr</tt> object behaves similarly to Control System Toolbox LTI objects. Hence a bode plot for exaple is plotted as follows</p><pre class="codeinput">figure, bode(P.nominal)
</pre><img vspace="5" hspace="5" src="doc_tplcomp_03.png" alt=""> <h2 id="7">Template Union</h2><p>Not all template computation methods mentioned above are made equal. It is sometimes useful to merge templates computed by different methods. This is done by <a href="matlab:doc('qtpl/union')"><tt>union</tt></a>.</p><p>Example:</p><pre class="codeinput">ctpl(P,<span class="string">'recgrid'</span>,w_tpl(7)) <span class="comment">% this replaces existing template at 10 rad/s</span>
T2 = P.templates(7);
T = union(T2,T1);
h = show(T1(7),<span class="string">'color'</span>,[1 0 0],<span class="string">'marker'</span>,<span class="string">'*'</span>);   <span class="comment">% return a figure handle h</span>
show(T(7),h,<span class="string">'color'</span>,[0 0 1],<span class="string">'marker'</span>,<span class="string">'o'</span>,<span class="string">'markersize'</span>,8) <span class="comment">% h is used to plot over</span>
P.templates = T; <span class="comment">% insert the new template in the plant P</span>
</pre><pre class="codeoutput">Calculating templates by recurcive grid
Accuracy: 5 [deg], 3 [dB] 
--&gt; for w=10 [rad/s] 
ADGRID: 2 uncertain and 0 constant parameter(s). Accuracy [5 deg 3dB]
# function evaluations = 2516
Final Border Size = 50

ans = 

  qplant with properties:

          num: [1&times;1 qexpression]
          den: [1&times;1 qpoly]
         pars: [2&times;1 qpar]
        delay: []
     unstruct: []
       uncint: []
         info: 'generated from [num,den] data on: 16-Feb-2019 22:33:51'
    templates: [9&times;1 qtpl]
      nominal: [1&times;1 qfr]

</pre><img vspace="5" hspace="5" src="doc_tplcomp_04.png" alt=""> <p>Alternatively, the new qtpls can be united with the old ones on the go by setting <tt>union</tt> option in <tt>ctpl</tt> to 1.</p><p>Example:</p><pre class="codeinput">ctpl(P,<span class="string">'recgrid'</span>,w_tpl(8),<span class="string">'union'</span>,1);
</pre><pre class="codeoutput">Calculating templates by recurcive grid
Accuracy: 5 [deg], 3 [dB] 
--&gt; for w=20 [rad/s] 
ADGRID: 2 uncertain and 0 constant parameter(s). Accuracy [5 deg 3dB]
# function evaluations = 2658
Final Border Size = 45
</pre><p>This is the time to move forward to <a href="matlab:web('doc_bounds.html')">Step 3: Horowitz-Sidi bounds computation</a></p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Template Computation

%% Overview
% The second stage in QFT design is to compute the uncertain templates.
% In *open Qsyn* templates are computed from |qplant| objects using the
% command <matlab:doc('qplant/ctpl') |ctpl|>. *Open Qsyn* offers several options for the template
% computation:
%
% * Grid
% * Random Grid
% * Random Samples
% * Recursive edge grid
% * Recursive grid
% * Cases
%
% To compute the templates using specified |method| at frequencies |w| type
%
%   ctpl(P,method,w) 
%
% The nominal plant is computed by <matlab:doc('qplant.cnom') |cnom|>.
% Use as 
%
%   cnom(P,w_nom)

%% 
% *Example*: compute the templates fot the plant 
% 
% $$ P(s) = \frac{\omega^2}{s^2 + 2\zeta \omega + \omega^2}, ~~ \omega \in [10,20], ~~ \zeta \in [0.3,0.5]$$ 
%
% at freqeuncies $\omega = \{ 0.1,~ 0.2,~ 0.5,~ 1,~ 3,~ 5,~ 10,~ 20,~ 50, \}$ rad/s,
% using a unifor grid of 5 points for $\omega$ and 6 points for $\zeta$.
omega = qpar('w',10,10,20,5);
zeta = qpar('z',0.3,0.3,0.5,6);
num = omega*omega;
den = [1 2*zeta*omega omega*omega];
P = qplant(num,den)
%%
% Since the nominal parameter values were not defined, we arbitrarly select 
% them as the lower values. We now compute thew desired templates and also
% the nominal case
w_tpl = [0.1 0.2 0.5 1 3 5 10 20 50];
ctpl(P,'grid',w_tpl);
w_nom = logspace(-2,2,200);
cnom(P,w_nom);

%% Plotting Templates
% Note that now the |templates| and |nominal| preperties are no longer
% empty. The computed templates are stores in a dedicated class 
% <matlab:doc('qtpl') |qtpl|>. They can be shown by the command 
% <matlab:doc('qtpl/show') |show|>. 
% To acsess the temalptes use |P.templates|. 
% The nominal point is always computed and stored at the first point in the
% template. It is marked with a square.
T1 = P.templates;
show(T1);
%% 
% To save time and keystrokes one can instead use the 
% <matlab:doc('qplant/showtpl') |showtpl|> command
% directly on the plant object. Both |qplt/show| and |qplant/showtpl| accepts 
% more input arguments that specify additional options. For e.g. to plot
% the template at 10 rad/s with red circle markers:
showtpl(P,10,'color',[1 0 0],'marker','o','mode','nonom')

%%
% The nominal is stored in a dedicated class <matlab:doc('qfr') |qfr|>. 
% A |qfr| object behaves similarly to Control System Toolbox LTI objects. 
% Hence a bode plot for exaple is plotted as follows
figure, bode(P.nominal)

%% Template Union
% Not all template computation methods mentioned above are made equal.
% It is sometimes useful to merge templates computed by different methods.
% This is done by <matlab:doc('qtpl/union') |union|>.
%
% Example:
ctpl(P,'recgrid',w_tpl(7)) % this replaces existing template at 10 rad/s 
T2 = P.templates(7);
T = union(T2,T1);
h = show(T1(7),'color',[1 0 0],'marker','*');   % return a figure handle h
show(T(7),h,'color',[0 0 1],'marker','o','markersize',8) % h is used to plot over
P.templates = T; % insert the new template in the plant P

%%
% Alternatively, the new qtpls can be united with the old ones on the go
% by setting |union| option in |ctpl| to 1. 
% 
% Example:
ctpl(P,'recgrid',w_tpl(8),'union',1);

%% 
% This is the time to move forward to 
% <matlab:web('doc_bounds.html') Step 3: Horowitz-Sidi bounds computation>  

##### SOURCE END #####
--></body></html>